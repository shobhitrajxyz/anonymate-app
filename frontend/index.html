<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>AnonyMate — TURN-only client</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: Arial, Helvetica, sans-serif; padding:18px; color:#111; }
    button { padding:10px 14px; margin-left:8px; }
    #log { white-space: pre-wrap; background:#f7f7f7; padding:12px; height:360px; overflow:auto; border:1px solid #ddd; }
    input { padding:6px 8px; }
    h2 { margin-top:0; }
  </style>
</head>
<body>
  <h2>AnonyMate — TURN-only client (force relay)</h2>

  <div>
    <label>Signaling URL:
      <input id="sigUrl" style="width:420px" value="https://anonymate-backend-chyg.onrender.com" />
    </label>
    <button id="connectBtn">Connect</button>
    <button id="joinBtn" disabled>Join Queue (Match)</button>
  </div>

  <p id="status">Status: idle</p>
  <div id="log"></div>

  <audio id="remoteAudio" autoplay playsinline></audio>

  <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
  <script>
    // Minimal helpful logging helper
    const logEl = document.getElementById('log');
    function log(...args){
      console.log(...args);
      logEl.innerText += args.join(' ') + '\n';
      logEl.scrollTop = logEl.scrollHeight;
    }

    // Global unhandled rejection logging
    window.addEventListener('unhandledrejection', e => log('UnhandledPromiseRejection:', e.reason));

    // TURN-only (openrelay.metered.ca) credentials — REPLACE if you have your own TURN
    const DEFAULT_ICE = [
      {
        urls: [
          "turn:openrelay.metered.ca:80?transport=udp",
          "turn:openrelay.metered.ca:443?transport=tcp",
          "turns:openrelay.metered.ca:443?transport=tcp"
        ],
        username: "openrelayproject",
        credential: "openrelayproject"
      }
    ];

    // UI elements
    const connectBtn = document.getElementById('connectBtn');
    const joinBtn = document.getElementById('joinBtn');
    const sigUrlInput = document.getElementById('sigUrl');
    const statusEl = document.getElementById('status');
    const remoteAudio = document.getElementById('remoteAudio');

    let socket = null;
    let pc = null;
    let localStream = null;
    let currentRoom = null;
    let isInitiator = false;

    // Connect / disconnect signaling
    connectBtn.onclick = () => {
      if (socket && socket.connected) {
        socket.close();
        connectBtn.innerText = "Connect";
        joinBtn.disabled = true;
        statusEl.innerText = "Status: disconnected";
        return;
      }

      const SIGNALING_URL = sigUrlInput.value.trim();
      log('[UI] connecting to', SIGNALING_URL);
      socket = io(SIGNALING_URL, { transports: ["websocket", "polling"] });

      socket.on("connect", () => {
        log('[SIG] connected', socket.id);
        connectBtn.innerText = "Disconnect";
        statusEl.innerText = "Status: connected";
        joinBtn.disabled = false;
      });

      socket.on("disconnect", (r) => {
        log('[SIG] disconnected', r);
        joinBtn.disabled = true;
        statusEl.innerText = "Status: disconnected";
      });

      socket.on("connect_error", (err) => {
        log('[SIG] connect_error', err && err.message ? err.message : err);
      });

      socket.on("user_count", (c) => log('[SIG] user_count', c));

      socket.on("match_found", async (payload) => {
        try { log('[SIG] match_found RECEIVED (full):', JSON.stringify(payload)); } catch(e){ log('[SIG] match_found', payload); }
        currentRoom = payload.roomId;
        isInitiator = !!payload.initiator;
        statusEl.innerText = `Status: matched (initiator=${isInitiator})`;
        await startWebRTCFlow(isInitiator);
      });

      socket.on("signal", async (data) => {
        // data: { from, payload }
        log('[SIG] signal RECEIVED (raw):', JSON.stringify(data));
        if (!pc) { log('[WEBRTC] no RTCPeerConnection yet'); return; }
        const d = data.payload;
        if (!d) return;

        if (d.type === "offer" || d.type === "answer") {
          log('[WEBRTC] remote SDP type:', d.type);
          await pc.setRemoteDescription(new RTCSessionDescription(d));
          if (d.type === "offer") {
            const answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);
            socket.emit("signal", { roomId: currentRoom, signalData: pc.localDescription });
            log('[WEBRTC] sent answer');
          }
        } else if (d.candidate) {
          log('[WEBRTC] remote ICE candidate received:', d.candidate && d.candidate.type);
          try { await pc.addIceCandidate(d); log('[WEBRTC] addIceCandidate OK'); }
          catch (e) { log('[WEBRTC] addIceCandidate ERROR', e); }
        }
      });
    };

    // Request to join matchmaking queue
    joinBtn.onclick = () => {
      if (!socket || !socket.connected) return alert("Not connected to signaling");
      socket.emit("join_queue");
      log('[SIG] join_queue sent');
      statusEl.innerText = "Status: waiting for match...";
    };

    // Create peer connection and force relay-only usage
    async function startWebRTCFlow(initiator) {
      if (pc) { try { pc.close(); } catch(e){} pc = null; }

      // FORCE relay-only here:
      pc = new RTCPeerConnection({
        iceServers: DEFAULT_ICE,
        iceTransportPolicy: "relay" // <<-- forces TURN-only candidates
      });

      pc.onicecandidate = (e) => {
        log('[WEBRTC] local icecandidate:', e.candidate ? (e.candidate.type + ' | ' + (e.candidate.candidate || '')) : 'null');
        if (e.candidate) {
          socket.emit("signal", { roomId: currentRoom, signalData: e.candidate });
          log('[SIG] sent local ICE candidate -> signaling');
        }
      };

      pc.oniceconnectionstatechange = () => {
        log('[WEBRTC] iceConnectionState:', pc.iceConnectionState);
        statusEl.innerText = `ICE: ${pc.iceConnectionState}`;
      };

      pc.ontrack = (e) => {
        log('[WEBRTC] ontrack remote stream');
        remoteAudio.srcObject = e.streams[0];
      };

      try {
        localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        localStream.getTracks().forEach(t => pc.addTrack(t, localStream));
        log('[WEBRTC] mic OK');
      } catch (err) {
        log('[WEBRTC] MIC ERROR:', err);
        alert("Microphone access needed");
        return;
      }

      if (initiator) {
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        socket.emit("signal", { roomId: currentRoom, signalData: pc.localDescription });
        log('[WEBRTC] offer sent');
      }

      log('[WEBRTC] peer ready (initiator=' + initiator + ')');
    }
  </script>
</body>
</html>