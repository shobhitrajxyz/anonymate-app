<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AnonyMate SSL Diagnostic</title>
    <style>
        body { background: #000; color: #0f0; font-family: monospace; padding: 20px; }
        .box { border: 1px solid #333; padding: 10px; margin-bottom: 10px; }
        button { padding: 15px; width: 100%; font-size: 1.2rem; cursor: pointer; background: #333; color: white; border: 1px solid #555; }
        #logs { height: 300px; overflow-y: scroll; border: 1px solid #555; background: #111; padding: 10px; white-space: pre-wrap; }
        .success { color: #00ff00; font-weight: bold; }
        .error { color: #ff0000; font-weight: bold; }
    </style>
</head>
<body>
    <h1>AnonyMate SSL Diagnostic</h1>
    
    <div class="box">
        <div id="status">Status: Idle</div>
        <div id="iceStatus">ICE Connection: New</div>
    </div>

    <button id="startBtn">START / FIND PARTNER</button>

    <div class="box">
        <h3>Live Logs:</h3>
        <div id="logs"></div>
    </div>

    <audio id="remoteAudio" autoplay playsinline></audio>

    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <script>
        const socket = io("https://anonymate-backend-chyg.onrender.com");
        const startBtn = document.getElementById('startBtn');
        const logs = document.getElementById('logs');
        const remoteAudio = document.getElementById('remoteAudio');

        // --- ðŸ”’ THE FIX: ENCRYPTED OPENRELAY KEYS ---
        // We use 'turns:' (Secure) on Port 443 (HTTPS Port)
        // Hardcoded so you don't need to copy-paste anything.
        const config = { 
            iceServers: [
                { 
                    urls: "turns:openrelay.metered.ca:443?transport=tcp",
                    username: "openrelayproject",
                    credential: "openrelayproject"
                },
                { 
                    urls: "turn:openrelay.metered.ca:80",
                    username: "openrelayproject",
                    credential: "openrelayproject"
                },
                { urls: "stun:stun.l.google.com:19302" }
            ],
            iceTransportPolicy: "all"
        };

        function log(msg, type = 'normal') {
            const span = type === 'error' ? ' class="error"' : type === 'success' ? ' class="success"' : '';
            logs.innerHTML += `<div${span}>[${new Date().toLocaleTimeString()}] ${msg}</div>`;
            logs.scrollTop = logs.scrollHeight;
        }

        let localStream, peerConnection, roomId;

        startBtn.onclick = () => {
            startBtn.disabled = true;
            log("1. Requesting Microphone...");
            navigator.mediaDevices.getUserMedia({ audio: true }).then(stream => {
                localStream = stream;
                log("2. Mic OK. Joining Server...");
                socket.emit('join_queue');
            }).catch(e => log("âŒ MIC ERROR: " + e.message, 'error'));
        };

        socket.on("match_found", async ({ roomId: id, initiator }) => {
            roomId = id;
            log(`3. Match Found! Initiator: ${initiator}`);
            createPeer(initiator);
        });

        function createPeer(initiator) {
            peerConnection = new RTCPeerConnection(config);
            localStream.getTracks().forEach(t => peerConnection.addTrack(t, localStream));

            // LOG EVERY CANDIDATE TO SEE IF RELAY WORKS
            peerConnection.onicecandidate = (e) => {
                if (e.candidate) {
                    if(e.candidate.type === 'relay') {
                        log("âš¡ SUCCESS: Generated SECURE RELAY Candidate!", 'success');
                    }
                    socket.emit("signal", { roomId, signalData: { type: "candidate", candidate: e.candidate } });
                }
            };

            peerConnection.oniceconnectionstatechange = () => {
                const state = peerConnection.iceConnectionState;
                document.getElementById('iceStatus').innerText = `ICE Connection: ${state}`;
                log(`ðŸ”„ Connection State: ${state}`);
                
                if (state === 'connected') {
                    log("âœ… SUCCESS: P2P CONNECTION ESTABLISHED!", 'success');
                    document.getElementById('status').innerText = "Status: CONNECTED!";
                } else if (state === 'failed') {
                    log("âŒ FAILED. Retrying with new candidates...", 'error');
                    peerConnection.restartIce(); // Auto-Retry Logic
                }
            };

            peerConnection.ontrack = (e) => {
                log("ðŸ”Š Audio Stream Received");
                remoteAudio.srcObject = e.streams[0];
                remoteAudio.play();
            };

            if (initiator) {
                peerConnection.createOffer().then(offer => {
                    peerConnection.setLocalDescription(offer);
                    socket.emit("signal", { roomId, signalData: { type: "offer", offer } });
                });
            }
        }

        socket.on("signal", async (data) => {
            if (!peerConnection) return;
            if (data.type === "offer") {
                await peerConnection.setRemoteDescription(new RTCSessionDescription(data.offer));
                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);
                socket.emit("signal", { roomId, signalData: { type: "answer", answer } });
            } 
            else if (data.type === "answer") {
                await peerConnection.setRemoteDescription(new RTCSessionDescription(data.answer));
            } 
            else if (data.type === "candidate") {
                await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
            }
        });
    </script>
</body>
</html>