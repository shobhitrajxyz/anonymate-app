<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>WebRTC Pair Demo</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
</head>
<body>
  <h3>Simple WebRTC Pair Demo</h3>
  <div>
    <label>Signaling URL:
      <input id="sigUrl" style="width:420px"
        value="https://anonymate-backend-chyg.onrender.com" />
    </label>
    <button id="connectBtn">Connect</button>
    <button id="joinBtn" disabled>Join Queue (Match)</button>
  </div>

  <div>
    <p id="status">Status: idle</p>
    <pre id="log" style="white-space:pre-wrap"></pre>
  </div>

  <audio id="remoteAudio" autoplay playsinline></audio>

  <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
  <script>
  // GLOBAL ERROR LOGGING
  window.addEventListener('unhandledrejection', e =>
    console.error("Unhandled Promise Rejection:", e.reason)
  );

  // === TURN/STUN CONFIG (FULL + WORKING) ===
  const DEFAULT_ICE = [
    { urls: "stun:stun.l.google.com:19302" },

    // IMPORTANT: these turn servers REQUIRE username + credential.
    {
      urls: [
        "turn:openrelay.metered.ca:80",
        "turn:openrelay.metered.ca:443?transport=tcp",
        "turns:openrelay.metered.ca:443?transport=tcp"
      ],
      username: "openrelayproject",
      credential: "openrelayproject"
    }
  ];

  // UI ELEMENTS
  const connectBtn = document.getElementById('connectBtn');
  const joinBtn = document.getElementById('joinBtn');
  const sigUrlInput = document.getElementById('sigUrl');
  const statusEl = document.getElementById('status');
  const logEl = document.getElementById('log');
  const remoteAudio = document.getElementById('remoteAudio');

  function log(...args) {
    console.log(...args);
    logEl.innerText += args.join(" ") + "\n";
  }

  let socket = null;
  let pc = null;
  let localStream = null;
  let currentRoom = null;
  let isInitiator = false;

  // CONNECT TO SIGNALING SERVER
  connectBtn.onclick = async () => {
    if (socket && socket.connected) {
      socket.close();
      connectBtn.innerText = "Connect";
      joinBtn.disabled = true;
      statusEl.innerText = "Status: disconnected";
      return;
    }

    const SIGNALING_URL = sigUrlInput.value.trim();
    log("[UI] connecting to", SIGNALING_URL);

    socket = io(SIGNALING_URL, { transports: ["websocket", "polling"] });

    socket.on("connect", () => {
      log("[SIG] connected", socket.id);
      connectBtn.innerText = "Disconnect";
      joinBtn.disabled = false;
      statusEl.innerText = "Status: connected";
    });

    socket.on("disconnect", (reason) => {
      log("[SIG] disconnected", reason);
      joinBtn.disabled = true;
      statusEl.innerText = "Status: disconnected";
    });

    socket.on("connect_error", (err) => {
      log("[SIG] connect_error", err.message || err);
    });

    socket.on("user_count", (c) => log("[SIG] user_count", c));

    // MATCH FOUND
    socket.on("match_found", async (payload) => {
      log("[SIG] match_found RECEIVED (full):", JSON.stringify(payload));

      currentRoom = payload.roomId;
      isInitiator = !!payload.initiator;
      statusEl.innerText = `Status: matched (initiator=${isInitiator})`;

      await startWebRTCFlow(isInitiator);
    });

    // SIGNALING DATA (offer/answer/candidates)
    socket.on("signal", async (data) => {
      log("[SIG] signal RECEIVED (raw):", JSON.stringify(data));

      if (!pc) {
        log("[WEBRTC] no RTCPeerConnection yet");
        return;
      }

      const d = data.payload;
      if (!d) return;

      // === SDP OFFER/ANSWER ===
      if (d.type === "offer" || d.type === "answer") {
        log("[WEBRTC] remote SDP type:", d.type);
        await pc.setRemoteDescription(new RTCSessionDescription(d));

        if (d.type === "offer") {
          const answer = await pc.createAnswer();
          await pc.setLocalDescription(answer);
          socket.emit("signal", { roomId: currentRoom, signalData: pc.localDescription });
          log("[WEBRTC] sent answer");
        }
      }
      // === ICE CANDIDATE ===
      else if (d.candidate) {
        log("[WEBRTC] remote ICE candidate received:", d.candidate.type);
        try {
          await pc.addIceCandidate(d);
          log("[WEBRTC] addIceCandidate OK");
        } catch (e) {
          log("[WEBRTC] addIceCandidate ERROR", e);
        }
      }
    });
  };

  // USER PRESSES "JOIN QUEUE"
  joinBtn.onclick = () => {
    if (!socket || !socket.connected) return alert("Not connected");
    socket.emit("join_queue");
    log("[SIG] join_queue sent");
    statusEl.innerText = "Status: waiting for match...";
  };

  // =====================================================
  // === START WEBRTC AFTER MATCH ========================
  // =====================================================
  async function startWebRTCFlow(initiator) {
    // reset old connection if any
    if (pc) { try { pc.close(); } catch(e){} }

    pc = new RTCPeerConnection({ iceServers: DEFAULT_ICE });

    // ICE candidate handler
    pc.onicecandidate = (e) => {
      log("[WEBRTC] local icecandidate:", e.candidate ? e.candidate.type : "null");
      if (e.candidate) {
        socket.emit("signal", {
          roomId: currentRoom,
          signalData: e.candidate
        });
      }
    };

    // Connection state logs
    pc.oniceconnectionstatechange = () => {
      log("[WEBRTC] iceConnectionState:", pc.iceConnectionState);
      statusEl.innerText = `ICE: ${pc.iceConnectionState}`;
    };

    // Remote audio
    pc.ontrack = (e) => {
      log("[WEBRTC] ontrack remote stream");
      remoteAudio.srcObject = e.streams[0];
    };

    try {
      // MIC ACCESS
      localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
      localStream.getTracks().forEach(t => pc.addTrack(t, localStream));
      log("[WEBRTC] mic OK");
    } catch (err) {
      log("[WEBRTC] MIC ERROR:", err);
      alert("Microphone access denied");
      return;
    }

    // If initiator, create and send offer
    if (initiator) {
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      socket.emit("signal", { roomId: currentRoom, signalData: pc.localDescription });
      log("[WEBRTC] offer sent");
    }

    log("[WEBRTC] peer ready (initiator=" + initiator + ")");
  }
  </script>
</body>
</html>
