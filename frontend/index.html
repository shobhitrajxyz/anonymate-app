<!-- index.html -->
<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>WebRTC pair demo</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
</head>
<body>
  <h3>Simple WebRTC Pair Demo</h3>
  <div>
    <label>Signaling URL: <input id="sigUrl" style="width:420px" value="https://anonymate-backend-chyg.onrender.com" /></label>
    <button id="connectBtn">Connect</button>
    <button id="joinBtn" disabled>Join Queue (Match)</button>
  </div>

  <div>
    <p id="status">Status: idle</p>
    <p id="log"></p>
  </div>

  <audio id="remoteAudio" autoplay playsinline></audio>

  <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
  <script>
  // CONFIG - change only if you know what you're doing
  const DEFAULT_ICE = [
    { urls: "stun:stun.l.google.com:19302" },
    // An example public metered relay (works for many apps). Replace if you run your own TURN.
    { urls: ["turn:openrelay.metered.ca:80", "turn:openrelay.metered.ca:443?transport=tcp"] }
  ];

  // UI
  const connectBtn = document.getElementById('connectBtn');
  const joinBtn = document.getElementById('joinBtn');
  const sigUrlInput = document.getElementById('sigUrl');
  const statusEl = document.getElementById('status');
  const logEl = document.getElementById('log');
  const remoteAudio = document.getElementById('remoteAudio');

  function log(...args) {
    console.log(...args);
    logEl.innerText = (logEl.innerText ? logEl.innerText + "\n" : "") + args.join(" ");
  }

  let socket = null;
  let pc = null;
  let localStream = null;
  let currentRoom = null;
  let isInitiator = false;

  connectBtn.onclick = async () => {
    if (socket && socket.connected) {
      socket.close();
      connectBtn.innerText = "Connect";
      joinBtn.disabled = true;
      statusEl.innerText = "Status: disconnected";
      return;
    }

    const SIGNALING_URL = sigUrlInput.value.trim();
    log("[UI] connecting to", SIGNALING_URL);
    socket = io(SIGNALING_URL, { transports: ["websocket", "polling"] });

    socket.on("connect", () => {
      log("[SIG] connected", socket.id);
      statusEl.innerText = "Status: connected";
      connectBtn.innerText = "Disconnect";
      joinBtn.disabled = false;
    });

    socket.on("disconnect", (r) => {
      log("[SIG] disconnected", r);
      statusEl.innerText = "Status: disconnected";
      joinBtn.disabled = true;
    });

    socket.on("connect_error", (err) => {
      log("[SIG] connect_error", err && err.message ? err.message : err);
      statusEl.innerText = "Status: connect_error";
    });

    socket.on("user_count", (c) => log("[SIG] user_count", c));

    socket.on("match_found", async (payload) => {
      log("[SIG] match_found RECEIVED", payload);
      currentRoom = payload.roomId;
      isInitiator = !!payload.initiator;
      statusEl.innerText = `Status: matched (initiator=${isInitiator})`;

      // start WebRTC flow
      await startWebRTCFlow(isInitiator);
    });

    socket.on("signal", async (data) => {
      log("[SIG] signal RECEIVED", data);
      if (!pc) {
        log("[WEBRTC] no RTCPeerConnection yet");
        return;
      }
      const d = data.payload;
      if (!d) return;

      if (d.type === "offer" || d.type === "answer") {
        await pc.setRemoteDescription(new RTCSessionDescription(d));
        log("[WEBRTC] setRemoteDescription", d.type);
        if (d.type === "offer") {
          const answer = await pc.createAnswer();
          await pc.setLocalDescription(answer);
          socket.emit("signal", { roomId: currentRoom, signalData: pc.localDescription });
          log("[WEBRTC] sent answer");
        }
      } else if (d.candidate) {
        try {
          await pc.addIceCandidate(d);
          log("[WEBRTC] added remote ICE candidate");
        } catch (e) {
          log("[WEBRTC] addIceCandidate error", e);
        }
      }
    });
  };

  joinBtn.onclick = () => {
    if (!socket || !socket.connected) return alert("Not connected to signaling");
    socket.emit("join_queue");
    log("[SIG] join_queue sent");
    statusEl.innerText = "Status: waiting for match...";
  };

  // WebRTC flow
  async function startWebRTCFlow(initiator) {
    // cleanup existing
    if (pc) {
      try { pc.close(); } catch(e){}
      pc = null;
    }

    pc = new RTCPeerConnection({ iceServers: DEFAULT_ICE });

    pc.onicecandidate = (e) => {
      log("[WEBRTC] icecandidate", e.candidate && e.candidate.type);
      if (e.candidate) {
        socket.emit("signal", { roomId: currentRoom, signalData: e.candidate });
      }
    };

    pc.oniceconnectionstatechange = () => {
      log("[WEBRTC] iceConnectionState:", pc.iceConnectionState);
      statusEl.innerText = `Status: iceState=${pc.iceConnectionState}`;
    };

    pc.ontrack = (e) => {
      log("[WEBRTC] ontrack", e.streams && e.streams[0]);
      remoteAudio.srcObject = e.streams[0];
    };

    try {
      localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
      localStream.getTracks().forEach(t => pc.addTrack(t, localStream));
    } catch (e) {
      log("[WEBRTC] getUserMedia failed", e);
      alert("Microphone access needed");
      return;
    }

    if (initiator) {
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      socket.emit("signal", { roomId: currentRoom, signalData: pc.localDescription });
      log("[WEBRTC] offer sent");
    }

    // show local status
    log("[WEBRTC] peer ready (initiator=" + initiator + ")");
  }
  </script>
</body>
</html>
