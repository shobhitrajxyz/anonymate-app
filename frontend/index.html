<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AnonyMate Diagnostic</title>
    <style>
        body { background: #000; color: #0f0; font-family: monospace; padding: 20px; }
        .box { border: 1px solid #333; padding: 10px; margin-bottom: 10px; }
        button { padding: 15px; width: 100%; font-size: 1.2rem; cursor: pointer; background: #333; color: white; border: 1px solid #555; }
        #logs { height: 300px; overflow-y: scroll; border: 1px solid #555; background: #111; padding: 10px; white-space: pre-wrap; }
    </style>
</head>
<body>
    <h1>AnonyMate Diagnostic Mode</h1>
    
    <div class="box">
        <div id="status">Status: Idle</div>
        <div id="iceStatus">ICE Connection: New</div>
        <div id="bytes">Data Received: 0</div>
    </div>

    <button id="startBtn">START / FIND PARTNER</button>

    <div class="box">
        <h3>Live Logs:</h3>
        <div id="logs"></div>
    </div>

    <audio id="remoteAudio" autoplay playsinline></audio>

    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <script>
        const socket = io("https://anonymate-backend-chyg.onrender.com");
        const startBtn = document.getElementById('startBtn');
        const logs = document.getElementById('logs');
        const remoteAudio = document.getElementById('remoteAudio');

        // --- â¬‡ï¸ INPUT YOUR METERED KEYS HERE â¬‡ï¸ ---
        const turnUser = "4c004e71f89e70a872bae606";
        const turnPass = "as7cdI2hhzUQh+87";
        // -------------------------------------------

        // Standard Config: Tries Everything. No strict blocks.
        const config = { 
            iceServers: [
                { urls: "stun:stun.l.google.com:19302" }, // Google STUN
                { 
                    urls: "turn:global.turn.metered.ca:80?transport=udp",
                    username: turnUser, credential: turnPass
                },
                { 
                    urls: "turn:global.turn.metered.ca:80?transport=tcp",
                    username: turnUser, credential: turnPass
                },
                { 
                    urls: "turn:global.turn.metered.ca:443?transport=tcp",
                    username: turnUser, credential: turnPass
                }
            ]
        };

        function log(msg) {
            logs.innerHTML += `[${new Date().toLocaleTimeString()}] ${msg}\n`;
            logs.scrollTop = logs.scrollHeight;
            console.log(msg);
        }

        let localStream, peerConnection, roomId;
        let candidateQueue = [];

        startBtn.onclick = () => {
            startBtn.disabled = true;
            log("1. Requesting Microphone...");
            navigator.mediaDevices.getUserMedia({ audio: true }).then(stream => {
                localStream = stream;
                log("2. Mic OK. Connecting to Server...");
                socket.emit('join_queue');
            }).catch(e => log("âŒ MIC ERROR: " + e.message));
        };

        socket.on("connect", () => log("âœ… Connected to Signaling Server"));

        socket.on("match_found", async ({ roomId: id, initiator, partnerCountry }) => {
            roomId = id;
            log(`3. Match Found! Partner: ${partnerCountry}. Initiator: ${initiator}`);
            document.getElementById('status').innerText = "Status: Connecting...";

            createPeer(initiator);
        });

        function createPeer(initiator) {
            peerConnection = new RTCPeerConnection(config);
            
            // Add Mic Stream
            localStream.getTracks().forEach(t => peerConnection.addTrack(t, localStream));

            // ICE Candidates (The Address Book)
            peerConnection.onicecandidate = (e) => {
                if (e.candidate) {
                    // Check if it's a Relay (TURN) candidate
                    if(e.candidate.type === 'relay') log("âš¡ Generated RELAY Candidate (TURN is working)");
                    socket.emit("signal", { roomId, signalData: { type: "candidate", candidate: e.candidate } });
                }
            };

            // Connection State Monitoring
            peerConnection.oniceconnectionstatechange = () => {
                const state = peerConnection.iceConnectionState;
                document.getElementById('iceStatus').innerText = `ICE Connection: ${state}`;
                log(`ðŸ”„ ICE State Changed: ${state}`);
                
                if (state === 'connected' || state === 'completed') {
                    log("âœ… P2P CONNECTION ESTABLISHED!");
                    document.getElementById('status').innerText = "Status: CONNECTED!";
                } else if (state === 'failed' || state === 'disconnected') {
                    log("âŒ ICE Connection Failed. Firewall blocked path.");
                }
            };

            // Audio Stream Handling
            peerConnection.ontrack = (e) => {
                log("ðŸ”Š Audio Stream Received from Partner");
                remoteAudio.srcObject = e.streams[0];
                remoteAudio.play().then(() => log("ðŸ”Š Playing Audio..."))
                                .catch(e => log("âš ï¸ Autoplay Blocked. Tap screen!"));
            };

            // STATS LOOP
            setInterval(() => {
                if(peerConnection && (peerConnection.iceConnectionState === 'connected' || peerConnection.iceConnectionState === 'completed')) {
                    peerConnection.getStats(null).then(stats => {
                        stats.forEach(report => {
                            if(report.type === 'inbound-rtp' && report.kind === 'audio') {
                                document.getElementById('bytes').innerText = `Data Received: ${report.bytesReceived}`;
                            }
                        });
                    });
                }
            }, 1000);

            // Signal Logic
            if (initiator) {
                peerConnection.createOffer().then(offer => {
                    peerConnection.setLocalDescription(offer);
                    socket.emit("signal", { roomId, signalData: { type: "offer", offer } });
                    log("ðŸ“¤ Sent Offer");
                });
            }
        }

        socket.on("signal", async (data) => {
            if (!peerConnection) return;
            if (data.type === "offer") {
                log("ðŸ“¥ Received Offer");
                await peerConnection.setRemoteDescription(new RTCSessionDescription(data.offer));
                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);
                socket.emit("signal", { roomId, signalData: { type: "answer", answer } });
                processQueue();
            } 
            else if (data.type === "answer") {
                log("ðŸ“¥ Received Answer");
                await peerConnection.setRemoteDescription(new RTCSessionDescription(data.answer));
                processQueue();
            } 
            else if (data.type === "candidate") {
                if (peerConnection.remoteDescription) {
                    await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
                } else {
                    candidateQueue.push(data.candidate);
                }
            }
        });

        async function processQueue() {
            while (candidateQueue.length > 0) {
                await peerConnection.addIceCandidate(new RTCIceCandidate(candidateQueue.shift()));
            }
        }
    </script>
</body>
</html>